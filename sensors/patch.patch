 Accelerometer.cpp            |   6 +-
 Android.mk                   |  36 +++--
 Bmp180.cpp                   |   2 +-
 CalibrationManager.cpp       |  27 +++-
 CalibrationModule.h          |  12 +-
 CompassSensor.cpp            |   6 +-
 GyroSensor.h                 |   2 +
 Gyroscope.cpp                |  80 +++++++++--
 InputEventReader.cpp         |   1 +
 NativeSensorManager.cpp      | 309 +++++++++++++++++++++++++++++++++----------
 NativeSensorManager.h        |  15 ++-
 SensorBase.cpp               |  10 +-
 SignificantMotion.cpp        | 163 +++++++++++++++++++++++
 SignificantMotion.h          |  58 ++++++++
 algo/common/common_wrapper.c |   3 +
 calmodule.cfg                |   2 +
 sensors.cpp                  |  11 +-
 sensors.h                    |   8 +-
 sensors_XML.cpp              | 215 +++++++++++++++++++++++++-----
 sensors_XML.h                |  10 +-
 20 files changed, 826 insertions(+), 150 deletions(-)

diff --git a/Accelerometer.cpp b/Accelerometer.cpp
index ad78638..c7033bd 100644
--- a/Accelerometer.cpp
+++ b/Accelerometer.cpp
@@ -68,8 +68,8 @@ AccelSensor::AccelSensor()
 #ifdef TARGET_8610
 		if (access(input_sysfs_path, F_OK)) {
 			input_sysfs_path_len -= strlen(SYSFS_I2C_SLAVE_PATH);
-			strcpy(&input_sysfs_path[input_sysfs_path_len],
-					SYSFS_INPUT_DEV_PATH);
+			strlcpy(&input_sysfs_path[input_sysfs_path_len],
+					SYSFS_INPUT_DEV_PATH, SYSFS_MAXLEN);
 			input_sysfs_path_len += strlen(SYSFS_INPUT_DEV_PATH);
 		}
 #endif
@@ -181,7 +181,7 @@ int AccelSensor::setDelay(int32_t, int64_t delay_ns)
 	fd = open(input_sysfs_path, O_RDWR);
 	if (fd >= 0) {
 		char buf[80];
-		sprintf(buf, "%d", delay_ms);
+		snprintf(buf, sizeof(buf), "%d", delay_ms);
 		write(fd, buf, strlen(buf)+1);
 		close(fd);
 		return 0;
diff --git a/Android.mk b/Android.mk
index 664cabc..c3fc5e6 100644
--- a/Android.mk
+++ b/Android.mk
@@ -1,4 +1,6 @@
 ifneq ($(filter msm8960 msm8610 msm8916 msm8909,$(TARGET_BOARD_PLATFORM)),)
+# Exclude SSC targets
+ifneq ($(TARGET_USES_SSC),true)
 # Disable temporarily for compilling error
 ifneq ($(BUILD_TINY_ANDROID),true)
 LOCAL_PATH := $(call my-dir)
@@ -6,21 +8,25 @@ LOCAL_PATH := $(call my-dir)
 # HAL module implemenation stored in
 include $(CLEAR_VARS)
 
-ifneq ($(filter msm8610,$(TARGET_BOARD_PLATFORM)),)
-  LOCAL_MODULE := sensors.$(TARGET_BOARD_PLATFORM)
-  LOCAL_CFLAGS := -DTARGET_8610
+ifeq ($(USE_SENSOR_MULTI_HAL),true)
+  LOCAL_MODULE := sensors.native
 else
-  ifneq ($(filter msm8916 msm8909,$(TARGET_BOARD_PLATFORM)),)
+  ifneq ($(filter msm8610,$(TARGET_BOARD_PLATFORM)),)
     LOCAL_MODULE := sensors.$(TARGET_BOARD_PLATFORM)
+    LOCAL_CFLAGS := -DTARGET_8610
   else
-    LOCAL_MODULE := sensors.msm8930
+    ifneq ($(filter msm8916 msm8909,$(TARGET_BOARD_PLATFORM)),)
+      LOCAL_MODULE := sensors.$(TARGET_BOARD_PLATFORM)
+    else
+      LOCAL_MODULE := sensors.msm8960
+    endif
   endif
-endif
 
-ifdef TARGET_2ND_ARCH
-LOCAL_MODULE_RELATIVE_PATH := hw
-else
-LOCAL_MODULE_PATH := $(TARGET_OUT_SHARED_LIBRARIES)/hw
+  ifdef TARGET_2ND_ARCH
+    LOCAL_MODULE_RELATIVE_PATH := hw
+  else
+    LOCAL_MODULE_PATH := $(TARGET_OUT_SHARED_LIBRARIES)/hw
+  endif
 endif
 
 LOCAL_MODULE_TAGS := optional
@@ -33,6 +39,12 @@ endif
 LOCAL_C_INCLUDES := $(TARGET_OUT_INTERMEDIATES)/KERNEL_OBJ/usr/include
 LOCAL_ADDITIONAL_DEPENDENCIES := $(TARGET_OUT_INTERMEDIATES)/KERNEL_OBJ/usr
 
+# Export calibration library needed dependency headers
+LOCAL_COPY_HEADERS_TO := sensors/inc
+LOCAL_COPY_HEADERS := 	\
+		CalibrationModule.h \
+		sensors.h
+
 LOCAL_SRC_FILES :=	\
 		sensors.cpp 			\
 		SensorBase.cpp			\
@@ -46,7 +58,8 @@ LOCAL_SRC_FILES :=	\
 		CalibrationManager.cpp \
 		NativeSensorManager.cpp \
 		VirtualSensor.cpp	\
-		sensors_XML.cpp
+		sensors_XML.cpp \
+		SignificantMotion.cpp
 
 LOCAL_C_INCLUDES += external/libxml2/include	\
 
@@ -93,4 +106,5 @@ LOCAL_SRC_FILES := calmodule.cfg
 include $(BUILD_PREBUILT)
 
 endif #BUILD_TINY_ANDROID
+endif #TARGET_USES_SSC
 endif #TARGET_BOARD_PLATFORM
diff --git a/Bmp180.cpp b/Bmp180.cpp
index fc9f799..a138ee5 100644
--- a/Bmp180.cpp
+++ b/Bmp180.cpp
@@ -159,7 +159,7 @@ int PressureSensor::setDelay(int32_t, int64_t delay_ns)
 	fd = open(input_sysfs_path, O_RDWR);
 	if (fd >= 0) {
 		char buf[80];
-		sprintf(buf, "%d", delay_ms);
+		snprintf(buf, sizeof(buf), "%d", delay_ms);
 		write(fd, buf, strlen(buf)+1);
 		close(fd);
 		return 0;
diff --git a/CalibrationManager.cpp b/CalibrationManager.cpp
index f9b9d68..e888918 100644
--- a/CalibrationManager.cpp
+++ b/CalibrationManager.cpp
@@ -38,9 +38,28 @@ IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include <CalibrationModule.h>
 #include "sensors.h"
 #include "CalibrationManager.h"
+#include "NativeSensorManager.h"
 
 ANDROID_SINGLETON_STATIC_INSTANCE(CalibrationManager);
 
+static int store_calibrate_params(struct sensor_t *sensor, struct sensors_event_t *bias)
+{
+	sensors_XML& sensor_XML(sensors_XML :: getInstance());
+	struct cal_result_t cal_result;
+	int err = 0;
+
+	cal_result.offset[0] = bias->data[0] ;
+	cal_result.offset[1] = bias->data[1] ;
+	cal_result.offset[2] = bias->data[2] ;
+	err = sensor_XML.write_sensors_params(sensor, &cal_result, CAL_DYNAMIC);
+	if (err < 0) {
+		ALOGE("write calibrate %s sensor error\n", sensor->name);
+		return err;
+	}
+
+	return 0;
+}
+
 int CalibrationManager::check_algo(const sensor_cal_algo_t *list)
 {
 	if (list->tag != SENSOR_CAL_ALGO_TAG)
@@ -67,7 +86,9 @@ void CalibrationManager::loadCalLibs()
 	int i = 0;
 	int count;
 	int tmp;
+	struct sensor_algo_args args;
 
+	args.store_calibrate_params = store_calibrate_params;
 	algo_count = 0;
 	algo_list = NULL;
 
@@ -129,7 +150,7 @@ void CalibrationManager::loadCalLibs()
 
 		modules[i]->dso = dso;
 
-		if (modules[i]->methods->init(modules[i])) {
+		if (modules[i]->methods->init(modules[i], &args)) {
 			ALOGE("init %s failed\n", modules[i]->id);
 			modules[i] = NULL;
 			continue;
@@ -219,12 +240,12 @@ const sensor_cal_algo_t* CalibrationManager::getCalAlgo(const sensor_t *s/* = NU
 	}
 
 	if (i != algo_count) {
-		ALOGI("found exactly compatible algo for type %d", s->type);
+		ALOGI("found exactly compatible algo for %s", s->name);
 		return list[i];
 	}
 
 	if (tmp != NULL)
-		ALOGI("found compatible algo for type %d", s->type);
+		ALOGI("found compatible algo for %s", s->name);
 
 	return tmp;
 }
diff --git a/CalibrationModule.h b/CalibrationModule.h
index 1226c24..b9eff5a 100644
--- a/CalibrationModule.h
+++ b/CalibrationModule.h
@@ -45,7 +45,7 @@ __BEGIN_DECLS
 #define TEMPERATURE_NAME	"temperature"
 #define PROXIMITY_NAME		"proximity"
 #define GRAVITY_NAME		"gravity"
-#define LINEAR_ACCELERATION_NAME	"liner_acceleration"
+#define LINEAR_ACCELERATION_NAME	"linear_acceleration"
 #define ROTATION_VECTOR_NAME	"rotation_vector"
 #define RELATIVE_HUMIDITY_NAME	"relative_humidity"
 #define AMBIENT_TEMPERATURE_NAME	"ambient_temperature"
@@ -71,6 +71,7 @@ enum {
 	CMD_ENABLE = 0, /* Enable status changed */
 	CMD_DELAY, /* Polling rate changed */
 	CMD_BATCH, /* Batching parameter changed */
+	CMD_INIT,
 };
 
 struct sensor_cal_algo_t;
@@ -79,6 +80,8 @@ struct sensor_cal_module_t;
 struct sensor_algo_args {
 	int enable;
 	int delay_ms;
+	struct sensor_t sensor;
+	int (*store_calibrate_params)(struct sensor_t *sensor, struct sensors_event_t *bias);
 };
 
 struct compass_algo_args {
@@ -86,6 +89,11 @@ struct compass_algo_args {
 	uint32_t reserved[16];
 };
 
+struct gyro_algo_args {
+	struct sensor_algo_args common;
+	float bias[3];
+};
+
 struct sensor_algo_methods_t {
 	int (*convert)(sensors_event_t *raw, sensors_event_t *result, struct sensor_algo_args *args);
 	/* Note that the config callback is called from a different thread as convert */
@@ -93,7 +101,7 @@ struct sensor_algo_methods_t {
 };
 
 struct sensor_cal_methods_t {
-	int (*init)(const struct sensor_cal_module_t* module);
+	int (*init)(const struct sensor_cal_module_t* module, struct sensor_algo_args *args);
 	void (*deinit)();
 	/* Return 0 on success */
 	int (*get_algo_list)(const struct sensor_cal_algo_t **algo);
diff --git a/CompassSensor.cpp b/CompassSensor.cpp
index 435d62d..cd3796c 100644
--- a/CompassSensor.cpp
+++ b/CompassSensor.cpp
@@ -160,7 +160,7 @@ int CompassSensor::setDelay(int32_t, int64_t delay_ns)
 	fd = open(input_sysfs_path, O_RDWR);
 	if (fd >= 0) {
 		char buf[80];
-		sprintf(buf, "%d", delay_ms);
+		snprintf(buf, sizeof(buf), "%d", delay_ms);
 		write(fd, buf, strlen(buf)+1);
 		close(fd);
 		return 0;
@@ -220,7 +220,9 @@ again:
 					mPendingEvent.timestamp = report_time+event->value;
 					break;
 				case SYN_REPORT:
-					mPendingEvent.timestamp = timevalToNano(event->time);
+					if (mUseAbsTimeStamp != true) {
+						mPendingEvent.timestamp = timevalToNano(event->time);
+					}
 					if (mEnabled) {
 						raw = mPendingEvent;
 
diff --git a/GyroSensor.h b/GyroSensor.h
index 5a11ce3..d4b58a1 100644
--- a/GyroSensor.h
+++ b/GyroSensor.h
@@ -33,10 +33,12 @@ struct input_event;
 class GyroSensor : public SensorBase {
 	InputEventCircularReader mInputReader;
 	sensors_event_t mPendingEvent;
+	sensor_t mSensor;
 	bool mHasPendingEvent;
 	int64_t mEnabledTime;
 
 	int setInitialState();
+	int read_dynamic_calibrate_params(struct sensor_t *sensor);
 
 public:
 	GyroSensor();
diff --git a/Gyroscope.cpp b/Gyroscope.cpp
index 4f6cbb4..07f59e5 100644
--- a/Gyroscope.cpp
+++ b/Gyroscope.cpp
@@ -86,6 +86,8 @@ GyroSensor::GyroSensor(struct SensorContext *context)
 	strlcpy(input_sysfs_path, context->enable_path, sizeof(input_sysfs_path));
 	input_sysfs_path_len = strlen(input_sysfs_path);
 	mUseAbsTimeStamp = false;
+	mSensor = *(context->sensor);
+	read_dynamic_calibrate_params(&mSensor);
 
 	enable(0, 1);
 }
@@ -192,7 +194,7 @@ int GyroSensor::setDelay(int32_t, int64_t delay_ns)
 	fd = open(input_sysfs_path, O_RDWR);
 	if (fd >= 0) {
 		char buf[80];
-		sprintf(buf, "%d", delay_ms);
+		snprintf(buf, sizeof(buf), "%d", delay_ms);
 		write(fd, buf, strlen(buf)+1);
 		close(fd);
 		return 0;
@@ -225,6 +227,7 @@ int GyroSensor::readEvents(sensors_event_t* data, int count)
 
 	int numEventReceived = 0;
 	input_event const* event;
+	sensors_event_t raw, result;
 
 #if FETCH_FULL_EVENT_BEFORE_RETURN
 again:
@@ -255,18 +258,43 @@ again:
 					}
 				break;
 				case SYN_REPORT:
-					{
-						if(mUseAbsTimeStamp != true) {
-							mPendingEvent.timestamp = timevalToNano(event->time);
-						}
-						if (mEnabled) {
-							if(mPendingEvent.timestamp >= mEnabledTime) {
-								*data++ = mPendingEvent;
-								numEventReceived++;
+					if(mUseAbsTimeStamp != true) {
+						mPendingEvent.timestamp = timevalToNano(event->time);
+					}
+					if (!mEnabled) {
+						break;
+					}
+					if(mPendingEvent.timestamp >= mEnabledTime) {
+						raw = mPendingEvent;
+						if (algo != NULL) {
+							if (algo->methods->convert(&raw, &result, NULL)) {
+								ALOGE("Calibrated failed\n");
+								result = raw;
 							}
-							count--;
+						} else {
+							result = raw;
 						}
+						*data = result;
+						data->version = sizeof(sensors_event_t);
+						data->sensor = mPendingEvent.sensor;
+						data->type = SENSOR_TYPE_GYROSCOPE;
+						data->timestamp = mPendingEvent.timestamp;
+						/* The raw data is stored inside sensors_event_t.data after
+						 * sensors_event_t.gyroscope. Notice that the raw data is
+						 * required to composite the virtual sensor uncalibrated
+						 * gyroscope field sensor.
+						 *
+						 * data[0~2]: calibrated gyroscope field data.
+						 * data[3]: gyroscope field data accuracy.
+						 * data[4~6]: uncalibrated gyroscope field data.
+						 */
+						data->data[4] = mPendingEvent.data[0];
+						data->data[5] = mPendingEvent.data[1];
+						data->data[6] = mPendingEvent.data[2];
+						data++;
+						numEventReceived++;
 					}
+					count--;
 				break;
 			}
 		} else {
@@ -289,3 +317,35 @@ again:
 	return numEventReceived;
 }
 
+int GyroSensor::read_dynamic_calibrate_params(struct sensor_t *sensor)
+{
+	sensors_XML& sensor_XML(sensors_XML :: getInstance());
+	struct cal_result_t cal_result;
+	int err = 0;
+
+	err = sensor_XML.read_sensors_params(sensor, &cal_result, 1);
+	if (err < 0) {
+		ALOGE("read dynamic calibrate %s sensor error\n", sensor->name);
+		cal_result.offset[0] = 0;
+		cal_result.offset[1] = 0;
+		cal_result.offset[2] = 0;
+	}
+
+	gyro_algo_args arg;
+
+	arg.bias[0] = cal_result.offset[0];
+	arg.bias[1] = cal_result.offset[1];
+	arg.bias[2] = cal_result.offset[2];
+	arg.common.sensor = *sensor;
+
+	if (algo != NULL) {
+		if (algo->methods->config(CMD_INIT, (sensor_algo_args*)&arg)) {
+			ALOGE("Init gyro calibration parameters failed\n");
+			return -1;
+		}
+	} else {
+		ALOGE("Init gyro algo error\n");
+	}
+
+	return 0;
+}
diff --git a/InputEventReader.cpp b/InputEventReader.cpp
index 1014f29..4d9a148 100644
--- a/InputEventReader.cpp
+++ b/InputEventReader.cpp
@@ -15,6 +15,7 @@
  */
 
 #include <stdint.h>
+#include <string.h>
 #include <errno.h>
 #include <unistd.h>
 #include <poll.h>
diff --git a/NativeSensorManager.cpp b/NativeSensorManager.cpp
index 1b9929d..b8adbd3 100644
--- a/NativeSensorManager.cpp
+++ b/NativeSensorManager.cpp
@@ -34,15 +34,18 @@ enum {
 	ORIENTATION = 0,
 	PSEUDO_GYROSCOPE,
 	ROTATION_VECTOR,
+	GAME_ROTATION_VECTOR,
 	LINEAR_ACCELERATION,
 	GRAVITY,
 	POCKET,
 	VIRTUAL_SENSOR_COUNT,
 };
 
+char NativeSensorManager::virtualSensorName[VIRTUAL_SENSOR_COUNT][SYSFS_MAXLEN];
+
 const struct sensor_t NativeSensorManager::virtualSensorList [VIRTUAL_SENSOR_COUNT] = {
 	[ORIENTATION] = {
-		.name = "oem-orientation",
+		.name = virtualSensorName[ORIENTATION],
 		.vendor = "oem",
 		.version = 1,
 		.handle = '_dmy',
@@ -63,7 +66,7 @@ const struct sensor_t NativeSensorManager::virtualSensorList [VIRTUAL_SENSOR_COU
 	},
 
 	[PSEUDO_GYROSCOPE] = {
-		.name = "oem-pseudo-gyro",
+		.name = virtualSensorName[PSEUDO_GYROSCOPE],
 		.vendor = "oem",
 		.version = 1,
 		.handle = '_dmy',
@@ -84,7 +87,7 @@ const struct sensor_t NativeSensorManager::virtualSensorList [VIRTUAL_SENSOR_COU
 	},
 
 	[ROTATION_VECTOR] = {
-		.name = "oem-rotation-vector",
+		.name = virtualSensorName[ROTATION_VECTOR],
 		.vendor = "oem",
 		.version = 1,
 		.handle = '_dmy',
@@ -104,8 +107,29 @@ const struct sensor_t NativeSensorManager::virtualSensorList [VIRTUAL_SENSOR_COU
 		.reserved = {},
 	},
 
+	[GAME_ROTATION_VECTOR] = {
+		.name = "qti-game-rotation-vector",
+		.vendor = "QTI",
+		.version = 1,
+		.handle = '_dmy',
+		.type = SENSOR_TYPE_GAME_ROTATION_VECTOR,
+		.maxRange = 1,
+		.resolution = 1.0f / (1<<24),
+		.power = 1,
+		.minDelay = 10000,
+		.fifoReservedEventCount = 0,
+		.fifoMaxEventCount = 0,
+#if defined(SENSORS_DEVICE_API_VERSION_1_3)
+		.stringType = NULL,
+		.requiredPermission = NULL,
+		.maxDelay = 0,
+		.flags = SENSOR_FLAG_CONTINUOUS_MODE,
+#endif
+		.reserved = {},
+	},
+
 	[LINEAR_ACCELERATION] = {
-		.name = "oem-linear-acceleration",
+		.name = virtualSensorName[LINEAR_ACCELERATION],
 		.vendor = "oem",
 		.version = 1,
 		.handle = '_dmy',
@@ -126,7 +150,7 @@ const struct sensor_t NativeSensorManager::virtualSensorList [VIRTUAL_SENSOR_COU
 	},
 
 	[GRAVITY] = {
-		.name = "oem-gravity",
+		.name = virtualSensorName[GRAVITY],
 		.vendor = "oem",
 		.version = 1,
 		.handle = '_dmy',
@@ -147,7 +171,7 @@ const struct sensor_t NativeSensorManager::virtualSensorList [VIRTUAL_SENSOR_COU
 	},
 
 	[POCKET] = {
-		.name = "oem-pocket",
+		.name = virtualSensorName[POCKET],
 		.vendor = "oem",
 		.version = 1,
 		.handle = '_dmy',
@@ -224,10 +248,11 @@ int NativeSensorManager::initVirtualSensor(struct SensorContext *ctx, int handle
 	ctx->sensor->handle = handle;
 	ctx->driver = new VirtualSensor(ctx);
 	ctx->data_fd = -1;
-	ctx->data_path = NULL;
-	ctx->enable_path = NULL;
 	ctx->is_virtual = true;
 
+	memset(ctx->enable_path, 0, sizeof(ctx->enable_path));
+	memset(ctx->data_path, 0, sizeof(ctx->data_path));
+
 	type_map.add(ctx->sensor->type, ctx);
 	handle_map.add(ctx->sensor->handle, ctx);
 
@@ -258,7 +283,7 @@ const struct SysfsMap NativeSensorManager::node_map[] = {
 };
 
 NativeSensorManager::NativeSensorManager():
-	mSensorCount(0), type_map(NULL), handle_map(NULL), fd_map(NULL)
+	mSensorCount(0), mScanned(false), mEventCount(0), type_map(NULL), handle_map(NULL), fd_map(NULL)
 {
 	int i;
 
@@ -360,62 +385,34 @@ void NativeSensorManager::dump()
 	ALOGI("\n");
 }
 
+void NativeSensorManager::compositeVirtualSensorName(const char *sensor_name, char *chip_name, int type)
+{
+	char *save_ptr;
+	const char *token;
+	char temp[SYSFS_MAXLEN];
+
+	strlcpy(temp, sensor_name, SYSFS_MAXLEN);
+	token = strtok_r(temp, "-_ ", &save_ptr);
+	if (token == NULL)
+		token = "";
+	strlcpy(chip_name, token, SYSFS_MAXLEN);
+	strlcat(chip_name, "-", SYSFS_MAXLEN);
+	strlcat(chip_name, type_to_name(type), SYSFS_MAXLEN);
+}
+
 int NativeSensorManager::getDataInfo() {
-	struct dirent **namelist;
-	char *file;
-	char path[PATH_MAX];
-	char name[80];
-	int nNodes;
 	int i, j;
-	int fd = -1;
 	struct SensorContext *list;
 	int has_acc = 0;
 	int has_compass = 0;
 	int has_gyro = 0;
 	int has_light = 0;
 	int has_proximity = 0;
-	int event_count = 0;
 	struct sensor_t sensor_mag;
 	struct sensor_t sensor_acc;
 	struct sensor_t sensor_light;
 	struct sensor_t sensor_proximity;
-
-	strlcpy(path, EVENT_PATH, sizeof(path));
-	file = path + strlen(EVENT_PATH);
-	nNodes = scandir(path, &namelist, 0, alphasort);
-	if (nNodes < 0) {
-		ALOGE("scan %s failed.(%s)\n", EVENT_PATH, strerror(errno));
-		return -1;
-	}
-
-	for (event_count = 0, j = 0; (j < nNodes) && (j < MAX_SENSORS); j++) {
-		if (namelist[j]->d_type != DT_CHR) {
-			continue;
-		}
-
-		strlcpy(file, namelist[j]->d_name, sizeof(path) - strlen(EVENT_PATH));
-
-		fd = open(path, O_RDONLY);
-		if (fd < 0) {
-			ALOGE("open %s failed(%s)", path, strerror(errno));
-			continue;
-		}
-
-		if (ioctl(fd, EVIOCGNAME(sizeof(name) - 1), &name) < 1) {
-			name[0] = '\0';
-		}
-
-		strlcpy(event_list[event_count].data_name, name, sizeof(event_list[0].data_name));
-		strlcpy(event_list[event_count].data_path, path, sizeof(event_list[0].data_path));
-		close(fd);
-		event_count++;
-	}
-
-	for (j = 0; j <nNodes; j++ ) {
-		free(namelist[j]);
-	}
-
-	free(namelist);
+	struct sensor_t sensor_gyro;
 
 	mSensorCount = getSensorListInner();
 	for (i = 0; i < mSensorCount; i++) {
@@ -428,20 +425,8 @@ int NativeSensorManager::getDataInfo() {
 		/* hardware sensor depend on itself */
 		list_add_tail(&list->dep_list, &item->list);
 
-		/* Initialize data_path and data_fd */
-		for (j = 0; (j < event_count) && (j < MAX_SENSORS); j++) {
-			if (strcmp(list->sensor->name, event_list[j].data_name) == 0) {
-				list->data_path = strdup(event_list[j].data_path);
-				break;
-			}
-
-			if (strcmp(event_list[j].data_name, type_to_name(list->sensor->type)) == 0) {
-				list->data_path = strdup(event_list[j].data_path);
-			}
-		}
-
-		if (list->data_path != NULL)
-			list->data_fd = open(list->data_path,O_RDONLY | O_CLOEXEC | O_NONBLOCK);
+		if (strlen(list->data_path) != 0)
+			list->data_fd = open(list->data_path, O_RDONLY | O_CLOEXEC | O_NONBLOCK);
 		else
 			list->data_fd = -1;
 
@@ -486,10 +471,14 @@ int NativeSensorManager::getDataInfo() {
 			case SENSOR_TYPE_GYROSCOPE:
 				has_gyro = 1;
 				list->driver = new GyroSensor(list);
+				sensor_gyro = *(list->sensor);
 				break;
 			case SENSOR_TYPE_PRESSURE:
 				list->driver = new PressureSensor(list);
 				break;
+			case SENSOR_TYPE_SIGNIFICANT_MOTION:
+				list->driver = new SmdSensor(list);
+				break;
 			default:
 				list->driver = NULL;
 				ALOGE("No handle %d for this type sensor!", i);
@@ -504,8 +493,11 @@ int NativeSensorManager::getDataInfo() {
 	 */
 	CalibrationManager &cm(CalibrationManager::getInstance());
 	struct SensorRefMap *ref;
+	char *chip;
 
 	if (has_light && has_proximity) {
+		compositeVirtualSensorName(sensor_proximity.name, virtualSensorName[POCKET], SENSOR_TYPE_POCKET);
+		ALOGD("pocket virtual sensor name changed to %s\n", virtualSensorName[POCKET]);
 		if (!initVirtualSensor(&context[mSensorCount], SENSORS_HANDLE(mSensorCount),
 				virtualSensorList[POCKET])) {
 			addDependency(&context[mSensorCount], sensor_proximity.handle);
@@ -515,6 +507,8 @@ int NativeSensorManager::getDataInfo() {
 	}
 
 	if (has_acc && has_compass) {
+		compositeVirtualSensorName(sensor_mag.name, virtualSensorName[ORIENTATION], SENSOR_TYPE_ORIENTATION);
+		ALOGD("orientation virtual sensor name changed to %s\n", virtualSensorName[ORIENTATION]);
 		/* HAL implemented orientation. Android will replace it for
 		 * platform with Gyro with SensorFusion.
 		 * The calibration manager will first match "oem-orientation" and
@@ -527,6 +521,8 @@ int NativeSensorManager::getDataInfo() {
 		}
 
 		if (!has_gyro) {
+			compositeVirtualSensorName(sensor_mag.name, virtualSensorName[ORIENTATION], SENSOR_TYPE_ORIENTATION);
+			ALOGD("orientation virtual sensor name changed to %s\n", virtualSensorName[ORIENTATION]);
 			/* Pseudo gyroscope is a pseudo sensor which implements by accelerometer and
 			 * magnetometer. Some sensor vendors provide such implementations. The pseudo
 			 * gyroscope sensor is low cost but the performance is worse than the actual
@@ -538,6 +534,8 @@ int NativeSensorManager::getDataInfo() {
 				mSensorCount++;
 			}
 
+			compositeVirtualSensorName(sensor_mag.name, virtualSensorName[LINEAR_ACCELERATION], SENSOR_TYPE_LINEAR_ACCELERATION);
+			ALOGD("liear acceleration virtual sensor name changed to %s\n", virtualSensorName[LINEAR_ACCELERATION]);
 			/* For linear acceleration */
 			if (!initVirtualSensor(&context[mSensorCount], SENSORS_HANDLE(mSensorCount),
 						virtualSensorList[LINEAR_ACCELERATION])) {
@@ -546,6 +544,8 @@ int NativeSensorManager::getDataInfo() {
 				mSensorCount++;
 			}
 
+			compositeVirtualSensorName(sensor_mag.name, virtualSensorName[ROTATION_VECTOR], SENSOR_TYPE_ROTATION_VECTOR);
+			ALOGD("rotation vector virtual sensor name changed to %s\n", virtualSensorName[ROTATION_VECTOR]);
 			/* For rotation vector */
 			if (!initVirtualSensor(&context[mSensorCount], SENSORS_HANDLE(mSensorCount),
 						virtualSensorList[ROTATION_VECTOR])) {
@@ -554,6 +554,8 @@ int NativeSensorManager::getDataInfo() {
 				mSensorCount++;
 			}
 
+			compositeVirtualSensorName(sensor_mag.name, virtualSensorName[GRAVITY], SENSOR_TYPE_GRAVITY);
+			ALOGD("gravity virtual sensor name changed to %s\n", virtualSensorName[GRAVITY]);
 			/* For gravity */
 			if (!initVirtualSensor(&context[mSensorCount], SENSORS_HANDLE(mSensorCount),
 						virtualSensorList[GRAVITY])) {
@@ -575,6 +577,25 @@ int NativeSensorManager::getDataInfo() {
 		}
 	}
 
+	if (has_gyro) {
+		sensor_gyro.type = SENSOR_TYPE_GYROSCOPE_UNCALIBRATED;
+		if (!initVirtualSensor(&context[mSensorCount], SENSORS_HANDLE(mSensorCount),
+					sensor_gyro)) {
+			addDependency(&context[mSensorCount], sensor_gyro.handle);
+			mSensorCount++;
+		}
+	}
+
+	if (has_acc && has_gyro) {
+		/* For game rotation vector */
+		if (!initVirtualSensor(&context[mSensorCount], SENSORS_HANDLE(mSensorCount),
+					virtualSensorList[GAME_ROTATION_VECTOR])) {
+			addDependency(&context[mSensorCount], sensor_acc.handle);
+			addDependency(&context[mSensorCount], sensor_gyro.handle);
+			mSensorCount++;
+		}
+	}
+
 	return 0;
 }
 
@@ -682,6 +703,128 @@ int NativeSensorManager::getNode(char *buf, char *path, const struct SysfsMap *m
 	return 0;
 }
 
+int NativeSensorManager::getEventPathOld(const struct SensorContext *list, char *event_path)
+{
+	struct dirent **namelist;
+	char *file;
+	char path[PATH_MAX];
+	char name[80];
+	int nNodes;
+	int fd = -1;
+	int j;
+
+	/* scan "/dev/input" to get information */
+	if (!mScanned) {
+		strlcpy(path, EVENT_PATH, sizeof(path));
+		file = path + strlen(EVENT_PATH);
+		nNodes = scandir(path, &namelist, 0, alphasort);
+		if (nNodes < 0) {
+			ALOGE("scan %s failed.(%s)\n", EVENT_PATH, strerror(errno));
+			return -1;
+		}
+
+		for (mEventCount = 0, j = 0; (j < nNodes) && (j < MAX_SENSORS); j++) {
+			if (namelist[j]->d_type != DT_CHR) {
+				continue;
+			}
+
+			strlcpy(file, namelist[j]->d_name, sizeof(path) - strlen(EVENT_PATH));
+
+			fd = open(path, O_RDONLY);
+			if (fd < 0) {
+				ALOGE("open %s failed(%s)", path, strerror(errno));
+				continue;
+			}
+
+			if (ioctl(fd, EVIOCGNAME(sizeof(name) - 1), &name) < 1) {
+				name[0] = '\0';
+			}
+
+			strlcpy(event_list[mEventCount].data_name, name, sizeof(event_list[0].data_name));
+			strlcpy(event_list[mEventCount].data_path, path, sizeof(event_list[0].data_path));
+			close(fd);
+			mEventCount++;
+		}
+
+		for (j = 0; j <nNodes; j++ ) {
+			free(namelist[j]);
+		}
+
+		free(namelist);
+		mScanned = true;
+	}
+
+	/* Initialize data_path and data_fd */
+	for (j = 0; (j < mEventCount) && (j < MAX_SENSORS); j++) {
+		if (strcmp(list->sensor->name, event_list[j].data_name) == 0) {
+			strlcpy(event_path, event_list[j].data_path, PATH_MAX);
+			break;
+		}
+
+		if (strcmp(event_list[j].data_name, type_to_name(list->sensor->type)) == 0) {
+			strlcpy(event_path, event_list[j].data_path, PATH_MAX);
+		}
+	}
+
+	return 0;
+}
+
+int NativeSensorManager::getEventPath(const char *sysfs_path, char *event_path)
+{
+	DIR *dir;
+	struct dirent *de;
+	char symlink[PATH_MAX];
+	int len;
+	char *needle;
+
+	dir = opendir(sysfs_path);
+	if (dir == NULL) {
+		ALOGE("open %s failed.(%s)\n", strerror(errno));
+		return -1;
+	}
+	if ((sysfs_path == NULL) || (event_path == NULL)) {
+		ALOGE("invalid NULL argument.");
+		return -EINVAL;
+	}
+
+	len = readlink(sysfs_path, symlink, PATH_MAX);
+	if (len < 0) {
+		ALOGE("readlink failed for %s(%s)\n", sysfs_path, strerror(errno));
+		return -1;
+	}
+
+	needle = strrchr(symlink, '/');
+	if (needle == NULL) {
+		ALOGE("unexpected symlink %s\n", symlink);
+		return -1;
+	}
+
+	if (strncmp(needle + 1, "input", strlen("input")) != 0) {
+		ALOGE("\n");
+		ALOGE("==========================Notice=================================");
+		ALOGE("sensors_classdev %s need to register as the child of input device\n", sysfs_path);
+		ALOGE("in order to speed up Android sensor service initialization time");
+		ALOGE("Please update your sensor driver.");
+		ALOGE("================================================================");
+		ALOGE("\n");
+
+		return -ENODEV;
+	}
+
+	strlcpy(event_path, EVENT_PATH, PATH_MAX);
+
+	while ((de = readdir(dir))) {
+		if (strncmp(de->d_name, "event", strlen("event")) == 0) {
+			strlcat(event_path, de->d_name, sizeof(de->d_name));
+			break;
+		}
+	}
+
+	closedir(dir);
+
+	return 0;
+}
+
 int NativeSensorManager::getSensorListInner()
 {
 	int number = 0;
@@ -737,10 +880,16 @@ int NativeSensorManager::getSensorListInner()
 			list->sensor->maxDelay = list->sensor->maxDelay * 1000; /* milliseconds to microseconds */
 #endif
 		list->sensor->handle = SENSORS_HANDLE(number);
-		list->data_path = NULL;
 
 		strlcpy(nodename, "", SYSFS_MAXLEN);
-		list->enable_path = strdup(devname);
+		strlcpy(list->enable_path, devname, PATH_MAX);
+
+		/* initialize data path */
+		strlcpy(nodename, "device", SYSFS_MAXLEN);
+
+		if (getEventPath(devname, list->data_path) == -ENODEV) {
+			getEventPathOld(list, list->data_path);
+		}
 
 		number++;
 	}
@@ -768,6 +917,10 @@ int NativeSensorManager::activate(int handle, int enable)
 
 	list->enable = enable;
 
+	/* one shot sensors don't act as base sensors */
+	if (list->sensor->flags & SENSOR_FLAG_ONE_SHOT_MODE)
+		return list->driver->enable(handle, enable);
+
 	/* Search for the background sensor for the sensor specified by handle. */
 	list_for_each(node, &list->dep_list) {
 		item = node_to_item(node, struct SensorRefMap, list);
@@ -919,6 +1072,10 @@ int NativeSensorManager::setDelay(int handle, int64_t ns)
 		return -EINVAL;
 	}
 
+	/* ignore setDelay call for one-shot sensors */
+	if (list->sensor->flags & SENSOR_FLAG_ONE_SHOT_MODE)
+		return 0;
+
 	if (ns < list->sensor->minDelay * 1000) {
 		ALOGW("%s delay is less than minDelay. Cast it to minDelay", list->sensor->name);
 		list->delay_ns = list->sensor->minDelay * 1000;
@@ -987,6 +1144,10 @@ int NativeSensorManager::batch(int handle, int64_t sample_ns, int64_t latency_ns
 		return -EINVAL;
 	}
 
+	/* ignore batch call for one-shot sensors */
+	if (list->sensor->flags & SENSOR_FLAG_ONE_SHOT_MODE)
+		return 0;
+
 	/* *sample_ns* is the same as *ns* passed to setDelay */
 	list->delay_ns = sample_ns;
 	list->latency_ns = latency_ns;
@@ -1008,13 +1169,17 @@ int NativeSensorManager::flush(int handle)
 	struct SensorRefMap *item;
 	struct listnode *node;
 
-	ALOGD("flush called\n", handle);
+	ALOGD("flush called:%d\n", handle);
 	list = getInfoByHandle(handle);
 	if (list == NULL) {
 		ALOGE("Invalid handle(%d)", handle);
 		return -EINVAL;
 	}
 
+	/* one shot sensors should return -EINVAL */
+	if (list->sensor->flags & SENSOR_FLAG_ONE_SHOT_MODE)
+		return -EINVAL;
+
 	list_for_each(node, &list->dep_list) {
 		item = node_to_item(node, struct SensorRefMap, list);
 		ret = item->ctx->driver->flush(item->ctx->sensor->handle);
@@ -1071,7 +1236,7 @@ int NativeSensorManager::calibrate(int handle, struct cal_cmd_t *para)
 	if (!para->save) {
 		return err;
 	}
-	err = sensor_XML.write_sensors_params(list->sensor, &cal_result);
+	err = sensor_XML.write_sensors_params(list->sensor, &cal_result, CAL_STATIC);
 	if (err < 0) {
 		ALOGE("write calibrate %s sensor error\n", list->sensor->name);
 		return err;
@@ -1090,7 +1255,7 @@ int NativeSensorManager::initCalibrate(const SensorContext *list)
 		return -EINVAL;
 	}
 	memset(&cal_result, 0, sizeof(cal_result));
-	err = sensor_XML.read_sensors_params(list->sensor, &cal_result);
+	err = sensor_XML.read_sensors_params(list->sensor, &cal_result, CAL_STATIC);
 	if (err < 0) {
 		ALOGE("read %s calibrate params error\n", list->sensor->name);
 		return err;
diff --git a/NativeSensorManager.h b/NativeSensorManager.h
index 9c4c051..69a87cd 100644
--- a/NativeSensorManager.h
+++ b/NativeSensorManager.h
@@ -49,6 +49,7 @@ IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include "GyroSensor.h"
 #include "PressureSensor.h"
 #include "VirtualSensor.h"
+#include "SignificantMotion.h"
 
 #include "sensors_extension.h"
 #include "sensors_XML.h"
@@ -75,8 +76,8 @@ enum {
 struct SensorContext {
 	char   name[SYSFS_MAXLEN]; // name of the sensor
 	char   vendor[SYSFS_MAXLEN]; // vendor of the sensor
-	char   *enable_path; // the control path of this sensor
-	char   *data_path; // the data path to get sensor events
+	char   enable_path[PATH_MAX]; // the control path of this sensor
+	char   data_path[PATH_MAX]; // the data path to get sensor events
 
 	struct sensor_t *sensor; // point to the sensor_t structure in the sensor list
 	SensorBase     *driver; // point to the sensor driver instance
@@ -92,8 +93,8 @@ struct SensorContext {
 };
 
 struct SensorEventMap {
-      char data_name[80];
-      char data_path[PATH_MAX];
+	char data_name[80];
+	char data_path[PATH_MAX];
 };
 
 struct SysfsMap {
@@ -118,13 +119,17 @@ class NativeSensorManager : public Singleton<NativeSensorManager> {
 	struct SensorEventMap event_list[MAX_SENSORS];
 	static const struct SysfsMap node_map[];
 	static const struct sensor_t virtualSensorList[];
+	static char virtualSensorName[][SYSFS_MAXLEN];
 
 	int mSensorCount;
+	bool mScanned;
+	int mEventCount;
 
 	DefaultKeyedVector<int32_t, struct SensorContext*> type_map;
 	DefaultKeyedVector<int32_t, struct SensorContext*> handle_map;
 	DefaultKeyedVector<int, struct SensorContext*> fd_map;
 
+	void compositeVirtualSensorName(const char *sensor_name, char *chip_name, int type);
 	int getNode(char *buf, char *path, const struct SysfsMap *map);
 	int getSensorListInner();
 	int getDataInfo();
@@ -134,6 +139,8 @@ class NativeSensorManager : public Singleton<NativeSensorManager> {
 	int initCalibrate(const SensorContext *list);
 	int initVirtualSensor(struct SensorContext *ctx, int handle, struct sensor_t info);
 	int addDependency(struct SensorContext *ctx, int handle);
+	int getEventPath(const char *sysfs_path, char *event_path);
+	int getEventPathOld(const struct SensorContext *list, char *event_path);
 public:
 	int getSensorList(const sensor_t **list);
 	inline SensorContext* getInfoByFd(int fd) { return fd_map.valueFor(fd); };
diff --git a/SensorBase.cpp b/SensorBase.cpp
index c543e5b..e60b0ac 100644
--- a/SensorBase.cpp
+++ b/SensorBase.cpp
@@ -102,7 +102,7 @@ bool SensorBase::hasPendingEvents() const {
 int64_t SensorBase::getTimestamp() {
     struct timespec t;
     t.tv_sec = t.tv_nsec = 0;
-    clock_gettime(CLOCK_MONOTONIC, &t);
+    clock_gettime(CLOCK_BOOTTIME, &t);
     return int64_t(t.tv_sec)*1000000000LL + t.tv_nsec;
 }
 
@@ -116,7 +116,7 @@ int SensorBase::openInput(const char* inputName) {
     dir = opendir(dirname);
     if(dir == NULL)
         return -1;
-    strcpy(devname, dirname);
+    strlcpy(devname, dirname, PATH_MAX);
     filename = devname + strlen(devname);
     *filename++ = '/';
     while((de = readdir(dir))) {
@@ -124,7 +124,7 @@ int SensorBase::openInput(const char* inputName) {
                 (de->d_name[1] == '\0' ||
                         (de->d_name[1] == '.' && de->d_name[2] == '\0')))
             continue;
-        strcpy(filename, de->d_name);
+        strlcpy(filename, de->d_name, PATH_MAX - strlen(SYSFS_CLASS));
         fd = open(devname, O_RDONLY);
         if (fd>=0) {
             char name[80];
@@ -132,7 +132,7 @@ int SensorBase::openInput(const char* inputName) {
                 name[0] = '\0';
             }
             if (!strcmp(name, inputName)) {
-                strcpy(input_name, filename);
+                strlcpy(input_name, filename, PATH_MAX);
                 break;
             } else {
                 close(fd);
@@ -209,7 +209,7 @@ int SensorBase::flush(int32_t handle)
          */
 
         /* Should return -EINVAL if the sensor is not enabled */
-        if ((!mEnabled) || (ctx == NULL)) {
+        if ((!mEnabled) || (ctx == NULL) || (ctx->sensor->flags & SENSOR_FLAG_ONE_SHOT_MODE)) {
                 ALOGE("handle:%d mEnabled:%d ctx:%p\n", handle, mEnabled, ctx);
                 return -EINVAL;
         }
diff --git a/SignificantMotion.cpp b/SignificantMotion.cpp
new file mode 100644
index 0000000..5afc4a4
--- /dev/null
+++ b/SignificantMotion.cpp
@@ -0,0 +1,163 @@
+/*--------------------------------------------------------------------------
+Copyright (c) 2015, The Linux Foundation. All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the name of The Linux Foundation nor
+      the names of its contributors may be used to endorse or promote
+      products derived from this software without specific prior written
+      permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NON-INFRINGEMENT ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+--------------------------------------------------------------------------*/
+
+#include <fcntl.h>
+#include <errno.h>
+#include <math.h>
+#include <poll.h>
+#include <unistd.h>
+#include <dirent.h>
+#include <sys/select.h>
+#include <cutils/log.h>
+
+#include "SignificantMotion.h"
+#include "sensors.h"
+
+/*****************************************************************************/
+        SmdSensor::SmdSensor(struct SensorContext *context)
+: SensorBase(NULL, NULL, context),
+        mInputReader(4)
+{
+        int handle = -1;
+
+        memset(mPendingEvent.data, 0, sizeof(mPendingEvent.data));
+        mPendingEvent.version = sizeof(sensors_event_t);
+        mPendingEvent.sensor = context->sensor->handle;
+        mPendingEvent.type = SENSOR_TYPE_SIGNIFICANT_MOTION;
+        mUseAbsTimeStamp = false;
+
+        /* SMD sensor has only one valid event */
+        mPendingEvent.data[0] = 1.0f;
+
+        data_fd = context->data_fd;
+        strlcpy(input_sysfs_path, context->enable_path, sizeof(input_sysfs_path));
+        input_sysfs_path_len = strlen(input_sysfs_path);
+
+        mEnabled = 0;
+}
+
+SmdSensor::~SmdSensor() {
+        if (mEnabled) {
+                enable(0, 0);
+        }
+}
+
+int SmdSensor::enable(int32_t, int en) {
+        int flags = en ? 1 : 0;
+        int fd;
+        char buf[2];
+        int err;
+
+        if (flags == mEnabled) {
+                ALOGW("significant motion sensor already %s\n", flags ? "enabled" : "disabled");
+                return 0;
+        }
+
+        strlcpy(&input_sysfs_path[input_sysfs_path_len],
+                        SYSFS_ENABLE, SYSFS_MAXLEN);
+        fd = open(input_sysfs_path, O_RDWR);
+        if (fd < 0) {
+                ALOGE("open %s failed.(%s)\n", input_sysfs_path, strerror(errno));
+                return -1;
+        }
+
+        buf[1] = 0;
+        buf[0] = flags ? '1':'0';
+
+        if (write(fd, buf, sizeof(buf)) < (ssize_t)sizeof(buf)) {
+                ALOGE("write %s to %s failed.(%s)\n", buf, input_sysfs_path, strerror(errno));
+                close(fd);
+                return -1;
+        }
+        close(fd);
+
+        mEnabled = flags;
+
+        return 0;
+}
+
+int SmdSensor::readEvents(sensors_event_t* data, int count)
+{
+        int hasEvent = 0;
+
+        if (count < 1)
+                return -EINVAL;
+
+        ssize_t n = mInputReader.fill(data_fd);
+        if (n < 0)
+                return n;
+
+        int numEventReceived = 0;
+        input_event const* event;
+
+        while (count && mInputReader.readEvent(&event)) {
+                int type = event->type;
+                if (type == EV_ABS) {
+                        float value = event->value;
+                        if (event->code == ABS_MISC) {
+                                hasEvent = 1;
+                        }
+                } else if (type == EV_SYN) {
+                        switch (event->code) {
+                                case SYN_TIME_SEC:
+                                        mUseAbsTimeStamp = true;
+                                        report_time = event->value*1000000000LL;
+                                        break;
+                                case SYN_TIME_NSEC:
+                                        mUseAbsTimeStamp = true;
+                                        mPendingEvent.timestamp = report_time+event->value;
+                                        break;
+                                case SYN_REPORT:
+                                        if (!mUseAbsTimeStamp)
+                                                mPendingEvent.timestamp = timevalToNano(event->time);
+
+                                        if (mEnabled && hasEvent) {
+                                                *data++ = mPendingEvent;
+                                                numEventReceived++;
+                                                count--;
+
+                                                /* one-shot sensor disabled automatically */
+                                                mEnabled = 0;
+                                                hasEvent = 0;
+                                        } else {
+                                                ALOGE("invalid significant motion sensor event while disabled\n");
+                                        }
+                                        break;
+                        }
+                } else {
+                        ALOGE("SmdSensor: unknown event (type=%d, code=%d)",
+                                        type, event->code);
+                }
+                mInputReader.next();
+        }
+
+        ALOGD("%d SMD event received. timestamp:%lld\n", numEventReceived, mPendingEvent.timestamp);
+
+        return numEventReceived;
+}
+
diff --git a/SignificantMotion.h b/SignificantMotion.h
new file mode 100644
index 0000000..b678738
--- /dev/null
+++ b/SignificantMotion.h
@@ -0,0 +1,58 @@
+/*--------------------------------------------------------------------------
+Copyright (c) 2015, The Linux Foundation. All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the name of The Linux Foundation nor
+      the names of its contributors may be used to endorse or promote
+      products derived from this software without specific prior written
+      permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NON-INFRINGEMENT ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+--------------------------------------------------------------------------*/
+
+#ifndef ANDROID_SIGNIFICANT_MOTION_SENSOR_H
+#define ANDROID_SIGNIFICANT_MOTION_SENSOR_H
+
+#include <stdint.h>
+#include <errno.h>
+#include <sys/cdefs.h>
+#include <sys/types.h>
+
+#include "SensorBase.h"
+#include "InputEventReader.h"
+#include "NativeSensorManager.h"
+
+/*****************************************************************************/
+
+struct input_event;
+
+class SmdSensor : public SensorBase {
+        InputEventCircularReader mInputReader;
+        sensors_event_t mPendingEvent;
+        public:
+        SmdSensor(struct SensorContext *context);
+        virtual ~SmdSensor();
+        virtual int readEvents(sensors_event_t* data, int count);
+        virtual bool hasPendingEvents() const {return false;};
+        virtual int enable(int32_t handle, int enabled);
+};
+
+/*****************************************************************************/
+
+#endif  // ANDROID_SIGNIFICANT_MOTION_SENSOR_H
diff --git a/algo/common/common_wrapper.c b/algo/common/common_wrapper.c
index bb84023..bdbae60 100644
--- a/algo/common/common_wrapper.c
+++ b/algo/common/common_wrapper.c
@@ -28,6 +28,7 @@ IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 --------------------------------------------------------------------------*/
 
 #include <stdio.h>
+#include <string.h>
 #include <CalibrationModule.h>
 #include <sensors.h>
 
@@ -468,6 +469,8 @@ static struct sensor_algo_methods_t pocket_methods = {
 };
 
 static const char* pocket_match_table[] = {
+	"ltr553-pocket",
+	"ap3426-pocket",
 	"oem-pocket",
 	NULL
 };
diff --git a/calmodule.cfg b/calmodule.cfg
index 3541e6a..60a9f57 100644
--- a/calmodule.cfg
+++ b/calmodule.cfg
@@ -1 +1,3 @@
 libcalmodule_common.so
+libcalmodule_gyroscope.so
+libcalmodule_qti_algo.so
diff --git a/sensors.cpp b/sensors.cpp
index 7d67fcb..562c467 100644
--- a/sensors.cpp
+++ b/sensors.cpp
@@ -237,10 +237,19 @@ int sensors_poll_context_t::batch(int handle, int sample_ns, int latency_ns)
 
 int sensors_poll_context_t::flush(int handle)
 {
+	int ret;
+	const char wakeMessage(WAKE_MESSAGE);
+	int result;
+
 	NativeSensorManager& sm(NativeSensorManager::getInstance());
 	Mutex::Autolock _l(mLock);
 
-	return sm.flush(handle);
+	ret = sm.flush(handle);
+
+	result = write(mWritePipeFd, &wakeMessage, 1);
+	ALOGE_IF(result<0, "error sending wake message (%s)", strerror(errno));
+
+	return ret;
 }
 /*****************************************************************************/
 
diff --git a/sensors.h b/sensors.h
index 6686569..eaeea29 100644
--- a/sensors.h
+++ b/sensors.h
@@ -84,7 +84,7 @@ __BEGIN_DECLS
 #define TEMPERATURE_NAME	"temperature"
 #define PROXIMITY_NAME		"proximity"
 #define GRAVITY_NAME		"gravity"
-#define LINEAR_ACCELERATION_NAME	"liner_acceleration"
+#define LINEAR_ACCELERATION_NAME	"linear_acceleration"
 #define ROTATION_VECTOR_NAME	"rotation_vector"
 #define RELATIVE_HUMIDITY_NAME	"relative_humidity"
 #define AMBIENT_TEMPERATURE_NAME	"ambient_temperature"
@@ -95,6 +95,7 @@ __BEGIN_DECLS
 #define STEP_COUNTER_NAME		"step_counter"
 #define STEP_DETECTOR_NAME		"step_detector"
 #define GEOMAGNETIC_ROTATION_VECTOR_NAME	"geomagnetic_field"
+#define POCKET_NAME			"pocket"
 
 /* The hardware sensor type supported by HAL */
 #define SUPPORTED_SENSORS_TYPE	( \
@@ -103,7 +104,8 @@ __BEGIN_DECLS
 		(1ULL << SENSOR_TYPE_PROXIMITY) | \
 		(1ULL << SENSOR_TYPE_LIGHT) | \
 		(1ULL << SENSOR_TYPE_GYROSCOPE ) | \
-		(1ULL << SENSOR_TYPE_PRESSURE))
+		(1ULL << SENSOR_TYPE_PRESSURE) | \
+		(1ULL << SENSOR_TYPE_SIGNIFICANT_MOTION))
 
 
 /*****************************************************************************/
@@ -151,6 +153,8 @@ static inline const char* type_to_name(int type)
 			return STEP_COUNTER_NAME;
 		case SENSOR_TYPE_GEOMAGNETIC_ROTATION_VECTOR:
 			return GEOMAGNETIC_ROTATION_VECTOR_NAME;
+		case SENSOR_TYPE_POCKET:
+			return POCKET_NAME;
 		default:
 			return "";
 	}
diff --git a/sensors_XML.cpp b/sensors_XML.cpp
index a581b2f..9786a48 100644
--- a/sensors_XML.cpp
+++ b/sensors_XML.cpp
@@ -1,5 +1,5 @@
 /*--------------------------------------------------------------------------
-Copyright (c) 2014, The Linux Foundation. All rights reserved.
+Copyright (c) 2014-2015, The Linux Foundation. All rights reserved.
 
 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are
@@ -31,72 +31,167 @@ IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include "sensors_XML.h"
 #include <cutils/log.h>
 #include "unistd.h"
+#include <fcntl.h>
+#include <sys/stat.h>
+#include <private/android_filesystem_config.h>
 
 #define SENSOR_XML_ROOT_ELEMENT "sensors"
 
 ANDROID_SINGLETON_STATIC_INSTANCE(sensors_XML);
 const static char *filepath[] = {
-    "/persist/sensors_calibration_params.xml",
-    "/data/sensors_calibration_param.xml"
+    "/persist/sensors/sensors_calibration_params.xml",
+    "/data/sensors_calibration_params.xml"
 };
 
 const char *sensor_param[] = {"offset_x", "offset_y", "offset_z", "threshold_h", "threshold_l", "bias"};
+const char *cal_state[] = {"static","dynamic"};
 sensors_XML :: sensors_XML()
     : mdoc(NULL)
 {
 }
 
-int sensors_XML :: write_sensors_params(struct sensor_t *sensor, struct cal_result_t *cal_result)
+static int config_file_copy()
+{
+    int bufsize;
+    int fd[2];
+    off_t offset;
+    char *ptr;
+    char *wptr;
+    int bytes_read, bytes_write;
+    int err = 0;
+
+    if ((fd[0] = open(filepath[0], O_RDONLY)) == -1) {
+        ALOGE("open calibrate sensor config error %d", errno);
+        return -errno;
+    }
+    if ((fd[1] = open(filepath[1], O_WRONLY | O_CREAT, S_IRUSR | S_IWUSR)) == -1) {
+        ALOGE("create calibrate sensor config error");
+        close(fd[0]);
+        return -errno;
+    }
+
+    offset = lseek(fd[0], 0, SEEK_END);
+    if (offset < 0) {
+        ALOGE("lseek %s error %d", filepath[0], errno);
+        err = -errno;
+        goto close_fd;
+    }
+
+    bufsize = offset;
+    ptr = (char*)malloc(bufsize);
+    if (ptr == NULL) {
+        ALOGE("malloc memory for %s error", filepath[1]);
+        err = -errno;
+        goto close_fd;
+    }
+
+    offset = lseek(fd[0], 0, SEEK_SET);
+    if (offset < 0) {
+        ALOGE("lseek %s error %d", filepath[0], errno);
+        err = -errno;
+        goto free_ptr;
+    }
+    bytes_read = read(fd[0], ptr, bufsize);
+    if (bytes_read == -1 && errno != EINTR) {
+        ALOGE("read calibrate sensor config error");
+        err = -errno;
+        goto free_ptr;
+    }
+
+    wptr = ptr;
+    while ((bytes_write = write(fd[1], wptr, bytes_read))) {
+        if (bytes_write == -1 && errno != EINTR) {
+            ALOGE("write calibrate sensor config error");
+            err = -errno;
+            goto free_ptr;
+        } else if (bytes_write == bytes_read) {
+            break;
+        }else if (bytes_write > 0) {
+            wptr += bytes_write;
+            bytes_read -= bytes_write;
+        }
+    }
+free_ptr:
+    free(ptr);
+close_fd:
+    close(fd[0]);
+    close(fd[1]);
+    return err;
+}
+
+int sensors_XML :: write_sensors_params(struct sensor_t *sensor, struct cal_result_t *cal_result, int state)
 {
     xmlNodePtr rootNode, curNode, newNode;
     xmlAttrPtr value;
     bool newcreate = false;
     char string[33];
+    int fnum = 0;
     int i = 0, j, MAX = 0;
+    int err = 0;
+
+    if (state < CAL_STATIC || state > CAL_DYNAMIC) {
+        ALOGE("state error\n");
+        return -1;
+    }
     if (cal_result == NULL) {
         ALOGE("Null pointer parameter\n");
         return -1;
     }
-    if (!access(filepath[0], F_OK)) {
-        mdoc = xmlReadFile(filepath[0], "UTF-8" , XML_PARSE_NOBLANKS);
-        if (mdoc == NULL) {
-            ALOGE("read calibration file error\n");
-            return -EINVAL;
+
+    if (state == 1)
+        fnum = 1;
+
+    if (!access(filepath[fnum], F_OK)) {
+        if (!access(filepath[fnum], W_OK)) {
+            mdoc = xmlReadFile(filepath[fnum], "UTF-8" , XML_PARSE_NOBLANKS);
+            if (mdoc == NULL) {
+                ALOGE("read calibration file error\n");
+                return -EINVAL;
+            }
+        } else {
+            ALOGE("No permission write file %s\n", filepath[fnum]);
+            return -1;
         }
     } else {
         mdoc = xmlNewDoc(BAD_CAST "1.0");
         if (mdoc == NULL) {
             ALOGE("create sensor calibration file error\n");
-            return -EINVAL;
+            return -1;
         }
         newcreate = true;
     }
+
     if(newcreate) {
         rootNode = xmlNewNode(NULL, BAD_CAST SENSOR_XML_ROOT_ELEMENT);
         xmlDocSetRootElement(mdoc, rootNode);
         curNode = xmlNewNode(NULL, BAD_CAST "sensor");
         xmlAddChild(rootNode, curNode);
         xmlNewProp(curNode, BAD_CAST "name", BAD_CAST sensor->name);
+        xmlNewProp(curNode, BAD_CAST "state", BAD_CAST cal_state[state]);
     } else {
         rootNode = xmlDocGetRootElement(mdoc);
         if (rootNode == NULL) {
             ALOGE("empty document\n");
             xmlFreeDoc(mdoc);
+            return -1;
         }
 
         if (xmlStrcmp(rootNode->name, BAD_CAST SENSOR_XML_ROOT_ELEMENT)) {
             ALOGE("root node != sensors\n");
             xmlFreeDoc(mdoc);
+            return -1;
         }
         curNode = rootNode->xmlChildrenNode;
         while(curNode != NULL) {
-            if (!xmlStrcmp(xmlGetProp(curNode, BAD_CAST "name"), BAD_CAST sensor->name))
+            if (!xmlStrcmp(xmlGetProp(curNode, BAD_CAST "name"), BAD_CAST sensor->name) &&
+                !xmlStrcmp(xmlGetProp(curNode, BAD_CAST "state"), BAD_CAST cal_state[state]))
                 break;
             curNode = curNode->next;
         }
     }
     switch(sensor->type) {
         case SENSOR_TYPE_ACCELEROMETER:
+        case SENSOR_TYPE_GYROSCOPE:
             i = 0;
             MAX = 3;
             break;
@@ -108,54 +203,107 @@ int sensors_XML :: write_sensors_params(struct sensor_t *sensor, struct cal_resu
         case SENSOR_TYPE_MAGNETIC_FIELD:
         case SENSOR_TYPE_PRESSURE:
         case SENSOR_TYPE_TEMPERATURE:
-        case SENSOR_TYPE_GYROSCOPE:
         default:
             break;
     }
     if (newcreate) {
-        for(j = 0; i < MAX; i++, j++) {
+        for(j = 0; i < MAX && j < 3; i++, j++) {
             snprintf(string, sizeof(string), "%d", cal_result->offset[j]);
-            xmlNewProp(curNode, BAD_CAST sensor_param[i], BAD_CAST string);
+            value = xmlNewProp(curNode, BAD_CAST sensor_param[i], BAD_CAST string);
+            if (value == NULL) {
+                ALOGE("write value in new create error\n");
+                xmlFreeDoc(mdoc);
+                return -1;
+            }
         }
     } else {
-        if(curNode == NULL) {
+        if (curNode == NULL) {
             curNode = xmlNewNode(NULL, BAD_CAST "sensor");
             xmlAddChild(rootNode, curNode);
             value = xmlNewProp(curNode, BAD_CAST "name", BAD_CAST sensor->name);
             if (value == NULL) {
-                ALOGE("\nname is NULL\n");
+                ALOGE("name is NULL\n");
+                xmlFreeDoc(mdoc);
+                return -1;
+            }
+            value = xmlNewProp(curNode, BAD_CAST "state", BAD_CAST cal_state[state]);
+            if (value == NULL) {
+                ALOGE("state is NULL\n");
+                xmlFreeDoc(mdoc);
+                return -1;
             }
-            for(j = 0; i < MAX; i++, j++) {
+            for(j = 0; i < MAX && j < 3; i++, j++) {
                 snprintf(string, sizeof(string), "%d", cal_result->offset[j]);
-                xmlNewProp(curNode, BAD_CAST sensor_param[i], BAD_CAST string);
+                value = xmlNewProp(curNode, BAD_CAST sensor_param[i], BAD_CAST string);
+                if (value == NULL) {
+                    ALOGE("write value error\n");
+                    xmlFreeDoc(mdoc);
+                    return -1;
+                }
             }
         } else {
-            for(j = 0; i < MAX; i++, j++) {
+            for(j = 0; i < MAX && j < 3; i++, j++) {
                 snprintf(string, sizeof(string), "%d", cal_result->offset[j]);
-                xmlSetProp(curNode, BAD_CAST sensor_param[i], BAD_CAST string);
+                value = xmlSetProp(curNode, BAD_CAST sensor_param[i], BAD_CAST string);
+                if (value == NULL) {
+                    ALOGE("set value error\n");
+                    xmlFreeDoc(mdoc);
+                    return -1;
+                }
             }
         }
     }
-    xmlSaveFormatFileEnc(filepath[0], mdoc, "UTF-8", 1);
+    if (xmlSaveFormatFileEnc(filepath[fnum], mdoc, "UTF-8", 1) == -1) {
+        ALOGE("save %s failed %s\n", filepath[fnum], strerror(errno));
+        xmlFreeDoc(mdoc);
+        return -1;
+    }
+    if (fnum == 0) {
+        if (getuid() != AID_ROOT) {
+            goto exit;
+        }
+        err = chown(filepath[fnum], AID_ROOT, AID_SYSTEM);
+        if (err != 0) {
+            ALOGE("chown %s failed %s", filepath[fnum], strerror(errno));
+            xmlFreeDoc(mdoc);
+            return -1;
+        }
+        err = chmod(filepath[fnum], 0660);
+        if (err != 0) {
+            ALOGE("chmod %s failed %s", filepath[fnum], strerror(errno));
+            xmlFreeDoc(mdoc);
+            return -1;
+        }
+    }
+
+exit:
     xmlFreeDoc(mdoc);
     return 0;
 }
 
-int sensors_XML :: read_sensors_params(struct sensor_t *sensor, struct cal_result_t *cal_result)
+int sensors_XML :: read_sensors_params(struct sensor_t *sensor, struct cal_result_t *cal_result, int state)
 {
     xmlNodePtr rootNode, curNode;
     int i = 0, j, MAX = 0;
 
+    if (state < CAL_STATIC || state > CAL_DYNAMIC) {
+        ALOGE("state error\n");
+        return -1;
+    }
     if (cal_result == NULL) {
         ALOGE("Null pointer parameter\n");
         return -1;
     }
-    if(!access(filepath[1], R_OK)) {
+    if (!access(filepath[1], R_OK)) {
         mdoc = xmlReadFile(filepath[1], "UTF-8" , XML_PARSE_RECOVER);
     } else if (!access(filepath[0], F_OK)){
-        char buf[200];
-        snprintf(buf, sizeof(buf), "cp %s %s", filepath[0], filepath[1]);
-        system(buf);
+        int err;
+
+        err = config_file_copy();
+        if (err < 0) {
+            ALOGE("copy %s error", filepath[0]);
+            return err;
+        }
         if (!access(filepath[1], R_OK)) {
             mdoc = xmlReadFile(filepath[1], "UTF-8" , XML_PARSE_RECOVER);
         } else {
@@ -180,12 +328,14 @@ int sensors_XML :: read_sensors_params(struct sensor_t *sensor, struct cal_resul
     }
     curNode = rootNode->xmlChildrenNode;
     while(curNode != NULL) {
-        if (!xmlStrcmp(xmlGetProp(curNode, BAD_CAST "name"), BAD_CAST sensor->name))
+        if (!xmlStrcmp(xmlGetProp(curNode, BAD_CAST "name"), BAD_CAST sensor->name) &&
+            !xmlStrcmp(xmlGetProp(curNode, BAD_CAST "state"), BAD_CAST cal_state[state]))
             break;
             curNode = curNode->next;
     }
     switch(sensor->type) {
         case SENSOR_TYPE_ACCELEROMETER:
+        case SENSOR_TYPE_GYROSCOPE:
             i = 0;
             MAX = 3;
             break;
@@ -197,18 +347,19 @@ int sensors_XML :: read_sensors_params(struct sensor_t *sensor, struct cal_resul
         case SENSOR_TYPE_MAGNETIC_FIELD:
         case SENSOR_TYPE_PRESSURE:
         case SENSOR_TYPE_TEMPERATURE:
-        case SENSOR_TYPE_GYROSCOPE:
         default:
             break;
     }
     if (curNode != NULL) {
         xmlChar* value;
-        for(j = 0; i < MAX; ++i, ++j) {
+        for(j = 0; i < MAX && j < 3; i++, j++) {
             value = xmlGetProp(curNode, BAD_CAST sensor_param[i]);
-            cal_result->offset[j] = atoi((char*)value);
+            if(value != NULL) {
+               cal_result->offset[j] = atoi((char*)value);
+            }
         }
     } else {
-        for(j = 0; j < 3; ++j) {
+        for(j = 0; j < 3; j++) {
             cal_result->offset[j] = 0;
         }
         ALOGE("The sensor %s calibrate parameters is not found\n", sensor->name);
@@ -222,7 +373,7 @@ int sensors_XML :: read_sensors_params(struct sensor_t *sensor, struct cal_resul
 int sensors_XML :: sensors_calibrate_reset()
 {
     int i;
-    for(i=0; i < 2; ++i) {
+    for(i=0; i < 2; i++) {
         if (access(filepath[i], F_OK)) {
             ALOGE("file is not exits\n");
             return -1;
diff --git a/sensors_XML.h b/sensors_XML.h
index d9ab5e8..f4f5ea1 100644
--- a/sensors_XML.h
+++ b/sensors_XML.h
@@ -37,12 +37,18 @@ IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 using namespace android;
 
+enum {
+    CAL_STATIC,
+    CAL_DYNAMIC,
+    CAL_COUNT,
+};
+
 class sensors_XML : public Singleton<sensors_XML> {
     friend class Singleton<sensors_XML>;
     xmlDocPtr mdoc;
 public:
-    int read_sensors_params(struct sensor_t *sensor, struct cal_result_t *cal_result);
-    int write_sensors_params(struct sensor_t *sensor, struct cal_result_t *cal_result);
+    int read_sensors_params(struct sensor_t *sensor, struct cal_result_t *cal_result, int state);
+    int write_sensors_params(struct sensor_t *sensor, struct cal_result_t *cal_result, int state);
     sensors_XML();
     int sensors_calibrate_reset();
     int sensors_rm_file();
